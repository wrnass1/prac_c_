# Составные типы в C

В языке C существуют несколько типов данных, которые позволяют хранить более сложные структуры данных, состоящие из множества элементов. Эти типы данных называются **составными (или агрегатными) типами**. К таким типам относятся:

1. **Массивы** (Arrays)
2. **Структуры** (Structures)
3. **Объединения** (Unions)
4. **Перечисления** (Enumerations)
5. **Типы указателей** (Pointers) — хотя это не совсем агрегатный тип, поскольку они просто содержат адреса, но их также можно рассматривать как средство для работы с составными данными.

Давайте подробно рассмотрим каждый из этих типов.

---

## 1. **Массивы (Arrays)**

**Массив** — это набор элементов одного типа данных, расположенных в памяти подряд. Массивы позволяют хранить несколько значений в одной переменной, например, список чисел, строк или других объектов.

**Синтаксис:**

```c
тип_данных имя_массива[размер];
```

Пример:

```c
int numbers[5];  // Массив из 5 целых чисел
char name[20];   // Массив символов для строки
```

**Особенности массива:**

- Все элементы массива имеют одинаковый тип.
- Индексы массива начинаются с 0.
- Размер массива должен быть известен на момент компиляции (если размер не является переменной, массив не может быть динамическим).
- Массивы передаются в функции как указатели, то есть на самом деле передается только адрес первого элемента массива, а не вся структура.

**Пример использования:**

```c
#include <stdio.h>

int main() {
    int arr[3] = {1, 2, 3};
    printf("arr[0]: %d\n", arr[0]);  // Выводит 1
    return 0;
}
```

---

## 2. **Структуры (Structures)**

**Структура** — это тип данных, который позволяет объединять различные типы данных в одну сущность. В структуре могут быть поля различных типов, например, строка, число и т.д.

**Синтаксис:**

```c
struct Название {
    тип_данных поле1;
    тип_данных поле2;
    // ...
};
```

Пример:

```c
struct Person {
    char name[50];
    int age;
    float height;
};
```

**Особенности структуры:**

- Структуры могут содержать поля разных типов.
- Поля структуры имеют разные имена, и можно обращаться к ним с помощью оператора `.`.
- Структуры полезны для группировки различных данных в одну единицу (например, данные о человеке или автомобиле).

**Пример использования:**

```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

int main() {
    struct Person p = {"Alice", 30, 1.75};
    printf("Name: %s, Age: %d, Height: %.2f\n", p.name, p.age, p.height);
    return 0;
}
```

---

## 3. **Объединения (Unions)**

**Объединение** — это тип данных, который позволяет хранить разные типы данных в одном месте, но в каждый момент времени в объединении может храниться только одно значение. Все члены объединения используют одну и ту же область памяти.

**Синтаксис:**

```c
union Название {
    тип_данных поле1;
    тип_данных поле2;
    // ...
};
```

Пример:

```c
union Data {
    int i;
    float f;
    char str[20];
};
```

**Особенности объединения:**

- В объединении только одно поле может содержать значение в любой момент времени.
- Размер объединения равен размеру самого большого поля.
- Поля объединения делят одну и ту же область памяти, то есть изменение одного поля повлияет на остальные.

**Пример использования:**

```c
#include <stdio.h>

union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    union Data data;

    data.i = 10; // Присваиваем значение целому числу
    printf("data.i = %d\n", data.i);

    data.f = 220.5; // Присваиваем значение типу float
    printf("data.f = %.2f\n", data.f);  // Теперь это значение, но содержимое 'i' теряется

    return 0;
}
```

---

## 4. **Перечисления (Enumerations)**

**Перечисление** позволяет задать набор именованных целых констант. Перечисления полезны, когда нужно работать с набором взаимосвязанных значений, таких как дни недели или состояния программы.

**Синтаксис:**

```c
enum Название {
    Константа1,
    Константа2,
    // ...
};
```

Пример:

```c
enum Day {
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};
```

**Особенности перечислений:**

- В перечислении каждая константа имеет целочисленное значение, начиная с 0 по умолчанию, но это значение можно изменить вручную.
- Перечисления обычно используются для улучшения читаемости кода и удобства работы с набором взаимосвязанных значений.

**Пример использования:**

```c
#include <stdio.h>

enum Day {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};

int main() {
    enum Day today = Wednesday;
    printf("Today is day number: %d\n", today);  // Выводит 3 (номер для Wednesday)
    return 0;
}
```

---

## 5. **Типы указателей (Pointers)**

**Указатели** в языке C — это переменные, которые содержат адреса других переменных. Указатели часто используются для работы с массивами, строками, структурами и динамически выделяемыми блоками памяти.

**Синтаксис:**

```c
тип_данных *имя_указателя;
```

Пример:

```c
int *ptr;  // Указатель на целое число
```

**Особенности указателей:**

- Указатели позволяют работать с памятью напрямую, что дает большую гибкость.
- Указатели могут быть использованы для динамического выделения памяти, работы с массивами и функциями.

**Пример использования:**

```c
#include <stdio.h>

int main() {
    int a = 10;
    int *ptr = &a;  // Указатель на переменную a

    printf("Value of a: %d\n", a);
    printf("Value via pointer: %d\n", *ptr);  // Разыменовываем указатель

    return 0;
}
```

---

### Заключение

В языке C составные (агрегатные) типы данных включают:

1. **Массивы** — набор однотипных элементов.
2. **Структуры** — комбинированные типы данных, содержащие несколько полей разных типов.
3. **Объединения** — типы данных, в которых несколько полей используют одну и ту же область памяти.
4. **Перечисления** — набор именованных целых констант.
5. **Указатели** — переменные, хранящие адреса других переменных, позволяют работать с памятью и динамически выделять память.

## Подробнее о структурах

Объявление и использование структур в языке C — важная часть работы с данными, когда нужно собрать несколько различных типов данных в одну сущность. Давайте подробно рассмотрим, как объявлять и работать с ними.

### 1. **Что такое структура в языке C?**

Структура (структурированный тип данных) в C — это агрегатный тип данных, который позволяет объединить переменные (поля) разных типов в одну логическую единицу. Структуры полезны, когда нужно работать с набором связанных данных, например, с информацией о человеке, автомобиле, книге и т.д.

### 2. **Основы объявления структуры**

Для того чтобы объявить структуру, нужно использовать ключевое слово `struct`, за которым следует название структуры, а затем список полей, заключённых в фигурные скобки `{}`.

**Синтаксис:**

```c
struct Название {
    тип_данных поле1;
    тип_данных поле2;
    // ...
};
```

Пример:

```c
struct Person {
    char name[50];
    int age;
    float height;
};
```

**Пояснение:**

- `struct Person` — объявление структуры с именем `Person`.
- В структуре `Person` три поля:
  - `name` — строка из 50 символов.
  - `age` — целое число, возраст.
  - `height` — число с плавающей точкой, рост.

### 3. **Объявление переменных структуры**

Чтобы использовать структуру, нужно создать её переменные. После объявления структуры можно создавать переменные этого типа.

**Синтаксис:**

```c
struct Название переменная1, переменная2;
```

Пример:
```c
struct Person person1, person2;
```

Теперь у нас есть две переменные типа `struct Person`: `person1` и `person2`, каждая из которых будет содержать поля `name`, `age` и `height`.

### 4. **Инициализация структуры**

Инициализировать поля структуры можно при её создании, используя синтаксис для инициализации массивов. Также можно присваивать значения полям структуры по отдельности.

**Пример 1: Инициализация при объявлении**

```c
struct Person person1 = {"Alice", 30, 1.75};
```

**Пример 2: Инициализация по отдельности**

```c
struct Person person1;
strcpy(person1.name, "Alice");  // Копируем строку в поле name
person1.age = 30;
person1.height = 1.75;
```

### 5. **Доступ к полям структуры**

Для того чтобы обратиться к полю структуры, используется оператор `.` (точка). Пример:

**Пример:**
```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

int main() {
    struct Person person1 = {"Alice", 30, 1.75};

    // Доступ к полям структуры
    printf("Name: %s\n", person1.name);
    printf("Age: %d\n", person1.age);
    printf("Height: %.2f\n", person1.height);

    return 0;
}
```

**Пояснение:**

- Для обращения к полям структуры `person1` используем точку: `person1.name`, `person1.age`, `person1.height`.

### 6. **Использование указателей на структуры**

Для работы с указателями на структуры используется оператор `->` для доступа к полям структуры через указатель.

**Пример:**

```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

int main() {
    struct Person person1 = {"Alice", 30, 1.75};
    struct Person *ptr = &person1;  // Указатель на структуру

    // Доступ через указатель
    printf("Name: %s\n", ptr->name);
    printf("Age: %d\n", ptr->age);
    printf("Height: %.2f\n", ptr->height);

    return 0;
}
```

**Пояснение:**

- Указатель на структуру `ptr` и доступ к полям с помощью `ptr->field`.

### 7. **Размер структуры**

Размер структуры зависит от количества и типов её полей. Для проверки размера структуры можно использовать оператор `sizeof`.

**Пример:**

```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

int main() {
    printf("Size of Person: %zu\n", sizeof(struct Person));  // Размер структуры
    return 0;
}
```

**Пояснение:**
- `sizeof(struct Person)` возвращает размер в байтах, занимаемый структурой.

### 8. **Передача структур в функции**

Структуры можно передавать в функции как по значению, так и по указателю.

**Передача по значению:**
```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

void printPerson(struct Person p) {
    printf("Name: %s, Age: %d, Height: %.2f\n", p.name, p.age, p.height);
}

int main() {
    struct Person person1 = {"Alice", 30, 1.75};
    printPerson(person1);  // Передача по значению
    return 0;
}
```

**Передача по указателю:**

```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
    float height;
};

void printPerson(struct Person *p) {
    printf("Name: %s, Age: %d, Height: %.2f\n", p->name, p->age, p->height);
}

int main() {
    struct Person person1 = {"Alice", 30, 1.75};
    printPerson(&person1);  // Передача по указателю
    return 0;
}
```

**Пояснение:**

- При передаче структуры по значению создаётся её копия, что может быть неэффективно для больших структур.
- При передаче по указателю мы избегаем копирования структуры, и функция работает с оригинальным объектом.

### 9. **Определение структуры в `typedef`**

Для удобства можно использовать `typedef`, чтобы не писать каждый раз `struct Person`, а просто использовать `Person`.

**Пример:**

```c
#include <stdio.h>

typedef struct {
    char name[50];
    int age;
    float height;
} Person;

int main() {
    Person person1 = {"Alice", 30, 1.75};

    printf("Name: %s, Age: %d, Height: %.2f\n", person1.name, person1.age, person1.height);

    return 0;
}
```

**Пояснение:**

- `typedef` позволяет задать псевдоним для структуры, и теперь вместо `struct Person` можно просто писать `Person`.

---

### Заключение

- Структуры позволяют объединять различные типы данных в одну логическую единицу.
- Объявление структур происходит с использованием `struct` и их полей.
- Доступ к полям структуры осуществляется через точку (`.`), а через указатели — через `->`.
- Структуры могут быть переданы в функции как по значению, так и по указателю.
- Для удобства работы с типами данных можно использовать `typedef`.
